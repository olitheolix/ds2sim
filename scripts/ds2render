#!env python
"""
Render training- or fligh images into a user specified folder.

Run this script with the -h option to see the possible render scenarios. Most
notable, these include a flight path along a fixed trajectory ("flight"), or
training images ("cubes" and "background").
"""

import os
import bz2
import sys
import json
import argparse
import textwrap
import PIL.Image
import collections
import ds2sim.horde
import ds2sim.camera

import numpy as np
import matplotlib.pyplot as plt


Node = collections.namedtuple('Node', 'handle label')


def parseCmdline():
    """Parse the command line arguments."""
    description = textwrap.dedent(f'''\
        Render DS2 related assets.

        Examples:
          ds2render --num-images 200 --num-cubes 300 flight
          ds2render --num-images 20 cubes
          ds2render --num-images 20 --resolution 512x512 background
    ''')

    # Create a parser and program description.
    parser = argparse.ArgumentParser(
        description=description,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    padd = parser.add_argument

    # Add the command line options.
    padd('mode', choices=['flight', 'cubes', 'background'],
         help='Which content to render')
    padd('--skybox', action='store_true', help='Add a skybox to mimic space')
    padd('--dst-path', metavar='', type=str,
         default=os.path.join(os.getcwd(), 'img'),
         help='Where to write images')
    padd('--resolution', metavar='', type=str, default='256x256',
         help='Width x Height, eg "512x256"')
    padd('--num-images', metavar='', type=int, default=10,
         help='Number of images to render')
    padd('--num-cubes', metavar='', type=int, default=200,
         help='Number of cubes in flight scene (only useful in flight mode)')
    padd('--jpg-quality', metavar='', type=int, default=90,
         help='JPEG quality (default=90)')
    padd('--seed', metavar='', type=int, default=0,
         help='Seed value to ensure reproducible scenes')
    padd('--fov', metavar='', type=int, default=45,
         help='Field of view of camera')
    padd('--debug', action='store_true', help='Create debug plots (depends on mode)')

    # Parse the actual arguments.
    param = parser.parse_args()

    # Unpack and sanity check the resolution string.
    try:
        res = param.resolution.split('x')
        assert len(res) == 2
        width, height = [int(_) for _ in res]
        assert width > 0 and height > 0
        param.width, param.height = width, height
        del param.resolution
    except (ValueError, AssertionError):
        print(f'Invalid resolution <{param.resolution}>')
        sys.exit()

    param.num_cubes = max(0, param.num_cubes)
    param.num_frames = max(0, param.num_images)
    return param


def addSun(h):
    # Add a light and place it far away. The parameters are such that it mimics
    # the SkyBox sun, altough there is a limit to how realistic this is.
    node = h.addLight()
    pos = 2000 * np.array([0, 1, 1], np.float32)
    tm = np.eye(4)
    tm[2, :3] = pos / np.linalg.norm(pos)
    tm[3, :3] = pos
    h.setNodeTransMat(node, tm.flatten().astype(np.float32).tobytes())
    return node


def renderGroundTruthCubes(param):
    """Render each of the ten cubes from different angles.

    The angles are chosen at random, but are identical for all cubes.

    The scene is devoid of other objects and has no skybox. In other words,
    each image contains exactly one cube in the centre, and the background is
    pure black.

    Args:
        param (namespace): command line parameters returned by argparse
    """
    h = ds2sim.horde.Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Add a light far away to mimic the sun.
    addSun(h)

    # Make the platform invisible.
    dst_path = os.path.join(param.dst_path, 'cubes')
    h.h3dSetNodeTransform(default_resources['base'], 0, 0, 0, 0, 0, 0, 0, 0, 0)

    # Add all 10 cubes and set their size to zero to make them invisible.
    nodes = {}
    for i in range(10):
        nodes[i] = h.addNode(default_resources[i])
        h.setNodeTransPes(nodes[i], [0, 0, 0], [0, 0, 0], [0, 0, 0])

    # Create a random orientation for the cube, a random position for the
    # camera (but always pointed to the center), render each of the
    # ten cube, and save each in their own file. Repeat this process as many
    # times as was specified in the --num-images argument.
    for i in range(param.num_images):
        # Compute a random position on the unit sphere.
        phi, theta = np.random.uniform(-1, 1, 2) * [2 * np.pi, np.pi]
        pos = np.array([
            np.sin(theta) * np.cos(phi),
            np.sin(theta) * np.sin(phi),
            np.cos(theta),
        ])

        # Compute a random right/up vector that is orthogonal to the position
        # vector, since that one specifies the forward vector.
        tmp = np.random.uniform(-1, 1, 3)
        tmp = tmp / np.linalg.norm(tmp)
        right = tmp - np.inner(tmp, pos) * pos
        right = right / np.linalg.norm(right)
        up = -np.cross(right, pos)

        # Convert right/up/pos into a camera matrix. Also, adjust the camera
        # distance to move it as close as possible without clipping the cube in
        # the rendered image. This is an empirical value.
        distance = 4.5
        cmat = ds2sim.camera.compileCameraMatrix(right, up, pos=distance * pos)
        tmp = np.fromstring(cmat, np.float32).reshape(4, 4)[:3, :3]
        assert cmat is not None
        del phi, theta, pos, right, up, distance, tmp

        # Compute random orientation of cube. Every cube will have the same
        # orientation.
        u = np.linalg.svd(np.random.uniform(-1, 1, size=(3, 3)))[0]
        tm = ds2sim.camera.compileCameraMatrix(right=u[0], up=u[1], pos=[0, 0, 0])
        assert tm is not None
        del u

        # Render each cube into a file.
        for j in range(10):
            dst_path = os.path.join(param.dst_path, f'{j:02d}')
            os.makedirs(dst_path, exist_ok=True)

            # Apply the transform to the current cube.
            h.setNodeTransMat(nodes[j], tm)

            # Render the scene to an image.
            img = h.renderScene(cmat, param.width, param.height, skybox=False)
            img = PIL.Image.fromarray(img)
            fname = os.path.join(dst_path, f'{i:04d}.jpg')
            img.save(fname, 'jpeg', quality=param.jpg_quality)

            # Set the scale to zero to make the cube invisible, because we only
            # want to see one cube in each image, not all 10.
            h.setNodeTransPes(nodes[j], [0, 0, 0], [0, 0, 0], [0, 0, 0])
            del j, img
        del tm
    print(f'Saved pure cube images to <{dst_path}>')


def renderGroundTruthBackground(param):
    """Render a scene devoid of cubes from random angles/positions.

    The scene still comprises the skybox and a randomly placed platform.

    Args:
        param (namespace): command line parameters returned by argparse
    """
    h = ds2sim.horde.Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Ensure the target directory exists.
    dst_path = os.path.join(param.dst_path, 'background')
    os.makedirs(dst_path, exist_ok=True)

    # Add a light far away to mimic the sun.
    addSun(h)

    # Add the platform.
    platform = h.addNode(default_resources['base'])

    # Render the empty scenes from several random angles/positions.
    for i in range(param.num_images):
        pos = 50 * np.random.uniform(-1, 1, 3)
        euler = 180 * np.random.uniform(-1, 1, 3)
        scale = 1 * np.random.uniform(0, 1, 3)
        h.setNodeTransPes(platform, pos.tolist(), euler.tolist(), scale.tolist())
        del pos, euler, scale

        # Compute random right/up/position vector for camera.
        u, _, _ = np.linalg.svd(np.random.uniform(-1, 1, size=(3, 3)))
        pos = 100 * np.random.uniform(-1, 1, 3)
        cmat = ds2sim.camera.compileCameraMatrix(right=u[0], up=u[1], pos=pos)
        assert cmat is not None
        del u

        # Render the scene and save the image.
        img = h.renderScene(cmat, param.width, param.height, skybox=True)
        img = PIL.Image.fromarray(img)
        fname = os.path.join(dst_path, f'{i:04d}.jpg')
        img.save(fname, 'jpeg', quality=param.jpg_quality)
    print(f'Saved background images to <{dst_path}>')


def renderPixelLabels(param, h, cmat, nodes):
    # Render the scene with all lights off. The objects will still be
    # (somewhat) visible due to the ambient light, but there will be no
    # shadows of any kind.
    img_all = h.renderScene(cmat, param.width, param.height, False)
    img_all = PIL.Image.fromarray(img_all)

    objID_at_pixel = np.zeros((param.height, param.width), np.uint16)
    for objID, (node, label) in nodes.items():
        # Render the scene without the current cube.
        trans = h.h3dGetNodeTransform(node)
        h.setNodeTransPes(node, trans[:3], trans[3:6], [0] * 3)
        diff = h.renderScene(cmat, param.width, param.height, False)
        h.setNodeTransPes(node, trans[:3], trans[3:6], trans[6:])

        # Compare the images with- and without the cube to determine which
        # pixels belong to it.
        diff = np.max(np.abs(img_all - diff), axis=2)
        diff_idx = np.nonzero(diff)

        # Set the pixel labels.
        assert 0 <= objID < 2 ** 16
        objID_at_pixel[diff_idx] = objID

    return objID_at_pixel.tolist()


def renderObjectPixels(param, h, cmat, nodes):
    # Backup the state of all nodes and set their scale to zero.
    trans = {}
    for objID, (node, _) in nodes.items():
        t = h.h3dGetNodeTransform(node)
        trans[objID] = t
        h.setNodeTransPes(node, t[:3], t[3:6], [0] * 3)
        del objID, node, t

    obj_pixels = {}
    for objID, (node, _) in nodes.items():
        t = trans[objID]
        # Render the scene with only the current cube in it.
        h.setNodeTransPes(node, t[:3], t[3:6], t[6:])
        diff = h.renderScene(cmat, param.width, param.height, False)
        h.setNodeTransPes(node, t[:3], t[3:6], [0] * 3)

        # Mark which pixels are occupied by the current object.
        diff_idx = np.nonzero(np.max(diff, axis=2))

        tmp = np.zeros((param.height, param.width), np.uint8)
        tmp[diff_idx] = 1
        obj_pixels[objID] = tmp.tolist()

    # Restore the scale of all objects to make them visible.
    for objID, (node, _) in nodes.items():
        t = trans[objID]
        h.setNodeTransPes(node, t[:3], t[3:6], t[6:])

    return obj_pixels


def renderFlightPath(param):
    """Populate the scene with cubes and render a virtual flight through it.

    This will also produce a meta.pickle file in the destination folder
    (specified on the command line). This file contains meta information about
    the scene, most notable the location and label of each cube as seen on the
    respective frame.

    Args:
        param (namespace): command line parameters returned by argparse
    """
    # Ensure the target directory exists.
    dst_path = os.path.join(param.dst_path, 'flightpath')
    os.makedirs(dst_path, exist_ok=True)

    h = ds2sim.horde.Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    nodes = []
    int2name = {0: 'background'}

    # Add the platform.
    platform_label = len(int2name)
    int2name[platform_label] = 'platform'
    node = h.addNode(default_resources['base'])
    h.setNodeTransPes(node, [0, -35, 0], [0, 0, 0], [1, .2, 1])
    nodes.append(Node(node, platform_label))
    del node, platform_label

    # Define a map that associates integers with human readable class names.
    # For technical reasons, the Zero label must be "background".
    cube0_label = len(int2name)
    int2name.update({i + cube0_label: f'Cube {i}' for i in range(10)})

    # Initialise the random generator to ensure reproducible results.
    np.random.seed(param.seed)

    # Draw a sequence of integers [0-9]. These will be the numbers displayed on
    # the cube. Use this sequence to also compile the corresponding list of
    # machine readable labels for each cube, ie add 1 to each number because
    # Zero is the background label.
    cube_nums = np.random.choice(np.arange(10), param.num_cubes)

    # Create random positions and orientations for each cube.
    cube_pos = 50 * np.random.uniform(-1, 1, size=(param.num_cubes, 3))
    cube_rot = 180 * np.random.uniform(-1, 1, size=(param.num_cubes, 3))

    # Each cube has the same size in the scene.
    scale = 2 * np.ones(3)

    # Create a flight path, that is, create the camera- position and vectors.
    # To ensure a "smooth" path that also connects the end to the beginning, we
    # will use trigonometric functions only.
    cam_mat = []
    for phi in np.linspace(0, 2 * np.pi, param.num_frames):
        pos = (30 * np.cos(phi), 20 * np.sin(phi), 30 * np.sin(phi))
        right = np.array([np.cos(3 * phi), 0, np.sin(3 * phi)])
        cmat = ds2sim.camera.compileCameraMatrix(right=right, up=[0, 1, 0], pos=pos)
        cam_mat.append(cmat)
        del phi, pos, right, cmat

    # Add each cube to the scene and set its transform.
    for idx, (pos, rot, num) in enumerate(zip(cube_pos, cube_rot, cube_nums)):
        node = h.addNode(default_resources[num])
        h.setNodeTransPes(node, pos, rot, scale)
        nodes.append(Node(node, int(num + cube0_label)))
        del idx, pos, rot, num, node
    del cube_pos, cube_rot, cube_nums

    nodes = {i + 1: node for i, node in enumerate(nodes)}
    objID2label = {k: v.label for k, v in nodes.items()}

    node_pos = [h.h3dGetNodeTransform(_)[:3] for _ in nodes]
    node_pos = np.array(node_pos)
    assert node_pos.shape == (len(nodes), 3)

    # Move the camera through the scene and save each frame as a JPG file.
    for frame, cmat in enumerate(cam_mat):
        obj_pixels = renderObjectPixels(param, h, cmat, nodes)
        objIDs = [k for k, v in obj_pixels.items() if np.max(v) > 0]
        obj_pixels = {objID: obj_pixels[objID] for objID in objIDs}
        frame_nodes = {objID: nodes[objID] for objID in objIDs}

        objID_at_pixel = renderPixelLabels(param, h, cmat, frame_nodes)

        bb_data = {}
        for objID, opix in obj_pixels.items():
            idx = np.nonzero(opix)
            assert len(idx[0]) > 0
            x0 = int(np.min(idx[1]))
            x1 = int(np.max(idx[1]))
            y0 = int(np.min(idx[0]))
            y1 = int(np.max(idx[0]))
            label = int(nodes[objID].label)
            bb_data[objID] = {'label': label, 'bbox': (x0, y0, x1, y1)}

        # Render the scene with the light on.
        light_node = addSun(h)
        img_light = h.renderScene(cmat, param.width, param.height, True)
        h.h3dRemoveNode(light_node)

        # Save the meta information.
        fname_img = os.path.join(dst_path, f'{frame:04d}.jpg')
        fname_meta = os.path.join(dst_path, f'{frame:04d}-meta.json.bz2')
        img_light = PIL.Image.fromarray(img_light)
        img_light.save(fname_img, 'jpeg', quality=param.jpg_quality)
        meta = {
            'seed': param.seed,
            'frame_no': frame,
            'int2name': int2name,
            'objID2label': objID2label,
            'num_frame': param.num_frames,
            'num_cubes': param.num_cubes,
            'bb_data': bb_data,
            'obj-pixels': obj_pixels,
            'objID-at-pixel': objID_at_pixel,
        }
        meta_raw = json.dumps(meta, indent=2).encode('utf8')
        print(f'{len(meta_raw):,} Bytes')
        bz2.open(fname_meta, 'wb').write(meta_raw)

        # Plot the image and label mask (debug only).
        if param.debug:
            objID_at_pixel = np.array(objID_at_pixel)
            p_labels = np.zeros_like(objID_at_pixel)
            for idx, objID in np.ndenumerate(objID_at_pixel):
                if objID > 0:
                    p_labels[idx] = objID2label[objID]
            plt.figure()
            plt.subplot(1, 3, 1).imshow(img_light)
            plt.subplot(1, 3, 2).imshow(p_labels, clim=[0, len(int2name)])
            plt.subplot(1, 3, 3).imshow(objID_at_pixel, clim=[0, max(nodes)])
            plt.figure()
            keys = list(obj_pixels.keys())[:25]
            for i, key in enumerate(keys):
                plt.subplot(5, 5, i + 1)
                plt.imshow(obj_pixels[key], clim=[0, 1])
                plt.title(f'ID: {key}')

    print(f'Saved flight path images to <{dst_path}>')

    if param.debug:
        plt.show()


def main():
    # Ensure the image sequence is repeatable.
    np.random.seed(0)

    param = parseCmdline()
    if param.mode == 'flight':
        renderFlightPath(param)
    elif param.mode == 'cubes':
        renderGroundTruthCubes(param)
    elif param.mode == 'background':
        renderGroundTruthBackground(param)
    elif param:
        assert False, f'Unknown mode <{param.mode}>'


if __name__ == '__main__':
    main()
