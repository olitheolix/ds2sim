#!env python
"""
Render training- or fligh images into a user specified folder.

Run this script with the -h option to see the possible render scenarios. Most
notable, these include a flight path along a fixed trajectory ("flight"), or
training images ("cubes" and "background").
"""

import os
import bz2
import sys
import json
import argparse
import textwrap
import PIL.Image
import ds2sim.horde
import ds2sim.camera

import numpy as np
import matplotlib.pyplot as plt


def parseCmdline():
    """Parse the command line arguments."""
    description = textwrap.dedent(f'''\
        Render DS2 related assets.

        Examples:
          ds2render --num-images 200 --num-cubes 300 flight
          ds2render --num-images 20 cubes
          ds2render --num-images 20 --resolution 512x512 background
    ''')

    # Create a parser and program description.
    parser = argparse.ArgumentParser(
        description=description,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    padd = parser.add_argument

    # Add the command line options.
    padd('mode', choices=['flight', 'cubes', 'background'],
         help='Which content to render')
    padd('--skybox', action='store_true', help='Add a skybox to mimic space')
    padd('--dst-path', metavar='', type=str,
         default=os.path.join(os.getcwd(), 'img'),
         help='Where to write images')
    padd('--resolution', metavar='', type=str, default='256x256',
         help='Width x Height, eg "512x256"')
    padd('--num-images', metavar='', type=int, default=10,
         help='Number of images to render')
    padd('--num-cubes', metavar='', type=int, default=200,
         help='Number of cubes in flight scene (only useful in flight mode)')
    padd('--jpg-quality', metavar='', type=int, default=90,
         help='JPEG quality (default=90)')
    padd('--seed', metavar='', type=int, default=0,
         help='Seed value to ensure reproducible scenes')
    padd('--fov', metavar='', type=int, default=45,
         help='Field of view of camera')
    padd('--debug', action='store_true', help='Create debug plots (depends on mode)')

    # Parse the actual arguments.
    param = parser.parse_args()

    # Unpack and sanity check the resolution string.
    try:
        res = param.resolution.split('x')
        assert len(res) == 2
        width, height = [int(_) for _ in res]
        assert width > 0 and height > 0
        param.width, param.height = width, height
        del param.resolution
    except (ValueError, AssertionError):
        print(f'Invalid resolution <{param.resolution}>')
        sys.exit()

    param.num_cubes = max(0, param.num_cubes)
    param.num_frames = max(0, param.num_images)
    return param


def addSun(h):
    # Add a light and place it far away. The parameters are such that it mimics
    # the SkyBox sun, altough there is a limit to how realistic this is.
    node = h.addLight()
    pos = 2000 * np.array([0, 1, 1], np.float32)
    tm = np.eye(4)
    tm[2, :3] = pos / np.linalg.norm(pos)
    tm[3, :3] = pos
    h.setNodeTransMat(node, tm.flatten().astype(np.float32).tobytes())
    return node


def projectCubePositions(param, cmat, labels, cube_pos):
    """ Return BBoxes position and size in normalised coordinates.

    The output will only BBox values for visible cubes, ie cube inside the
    camera frustrum. Essentially, this function will compute the screen
    position of all `cube_pos` in the exact same way as OpenGL does when
    it renders the scene.

    Inputs:
        param: command line parameters
        cmat: Array[16, float32]
            Camera matrix
        labels: Array[N]
            List of labels (eg strings or integers) for the corresponding entry
            in the `cube_pos` array.
        cube_pos: Array[N, 3]
            The 3D position of the cube centres.

    Returns:
        pos: Array[N, 3]
            BBox position. The first two dimension are in normalised screen
            coordinates [0, 1]. The last one is depth and is the true z-value
            of the cube. NOTE: this array will only contain visible cubes and
            N may thus be smaller than the N for `cube_pos` input.
        labels: Array[N]
            The labels that correspond to each returned BBox.
        bb_rects: Integer Array[N, 4]
            The upper left and lower right corner, ie (x0, y0, x1, y1).
        picked_idx: List[N]
            Integer array that lists the cube indices that were picked.
    """
    assert labels.ndim == 1
    assert cube_pos.ndim == 2 and cube_pos.shape[1] == 3

    # Camera parameters.
    fov = param.fov / 2
    fov = np.tan(fov * np.pi / 180)
    aspect_ratio = param.width / param.height

    # To track all cube indices that will be picked we create an artificial
    # enumeration.
    pick_idx = np.arange(len(labels))

    # Convert flat camera matrix into 4x4 transform.
    cmat = np.fromstring(cmat, np.float32).reshape(4, 4)
    assert cmat.shape == (4, 4)

    # Undo the camera transform of the cube centre positions.
    tmp = (cube_pos - cmat[3, :3]) @ cmat[:3, :3].T
    x, y, z = tmp[:, 0], tmp[:, 1], tmp[:, 2]
    z = -z
    del tmp, cmat

    # Filter out all cubes that are in front of the camera.
    idx = np.nonzero(z > 0.001)
    x, y, z, bb_labels = x[idx], y[idx], z[idx], labels[idx]
    pick_idx = pick_idx[idx]
    del labels

    # Project the 3D centre positions onto the 2D camera plane. This will
    # result in values in the interval [-1, 1].
    x = x / (z * fov * aspect_ratio)
    y = y / (z * fov)

    # Remove the cubes outside the camera frustrum. We add some slack because
    # the position only denote the centre, but even if the centre is outside
    # the frustrum it may still be possible to guess the object and its BBox.
    bound = 1.2
    cond_x = (-bound < x) & (x < bound)
    cond_y = (-bound < y) & (y < bound)
    idx = np.nonzero(cond_x & cond_y)
    x, y, z, bb_labels = x[idx], y[idx], z[idx], bb_labels[idx]
    pick_idx = pick_idx[idx]
    del bound, cond_x, cond_y, idx

    # Map from [-1, 1] to [0, 1].
    x = (x + 1) / 2
    y = 1 - (y + 1) / 2

    # Compile the three coordinates into a (N, 3) matrix.
    pos = np.vstack([x, y, z]).T

    # The (square) BBox size is determined by its distance from the camera plane.
    hlen_x = 4 / (aspect_ratio * z)
    hlen_y = 4 / z
    bb_rects = np.zeros((len(hlen_x), 4), np.float32)
    bb_rects[:, 0] = param.width * (x - hlen_x)
    bb_rects[:, 2] = param.width * (x + hlen_x)
    bb_rects[:, 1] = param.height * (y - hlen_y)
    bb_rects[:, 3] = param.height * (y + hlen_y)

    # Convert the BBox corners to integers. NOTE: the BBox corners may be
    # outside the image because parts of the object may be outside as well.
    bb_rects = bb_rects.astype(np.int32)
    return pos, bb_labels, bb_rects, pick_idx


def renderGroundTruthCubes(param):
    """Render each of the ten cubes from different angles.

    The angles are chosen at random, but are identical for all cubes.

    The scene is devoid of other objects and has no skybox. In other words,
    each image contains exactly one cube in the centre, and the background is
    pure black.

    Args:
        param (namespace): command line parameters returned by argparse
    """
    h = ds2sim.horde.Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Add a light far away to mimic the sun.
    addSun(h)

    # Make the platform invisible.
    dst_path = os.path.join(param.dst_path, 'cubes')
    h.h3dSetNodeTransform(default_resources['base'], 0, 0, 0, 0, 0, 0, 0, 0, 0)

    # Add all 10 cubes and set their size to zero to make them invisible.
    nodes = {}
    for i in range(10):
        nodes[i] = h.addNode(default_resources[i])
        h.setNodeTransPes(nodes[i], [0, 0, 0], [0, 0, 0], [0, 0, 0])

    # Create a random orientation for the cube, a random position for the
    # camera (but always pointed to the center), render each of the
    # ten cube, and save each in their own file. Repeat this process as many
    # times as was specified in the --num-images argument.
    for i in range(param.num_images):
        # Compute a random position on the unit sphere.
        phi, theta = np.random.uniform(-1, 1, 2) * [2 * np.pi, np.pi]
        pos = np.array([
            np.sin(theta) * np.cos(phi),
            np.sin(theta) * np.sin(phi),
            np.cos(theta),
        ])

        # Compute a random right/up vector that is orthogonal to the position
        # vector, since that one specifies the forward vector.
        tmp = np.random.uniform(-1, 1, 3)
        tmp = tmp / np.linalg.norm(tmp)
        right = tmp - np.inner(tmp, pos) * pos
        right = right / np.linalg.norm(right)
        up = -np.cross(right, pos)

        # Convert right/up/pos into a camera matrix. Also, adjust the camera
        # distance to move it as close as possible without clipping the cube in
        # the rendered image. This is an empirical value.
        distance = 4.5
        cmat = ds2sim.camera.compileCameraMatrix(right, up, pos=distance * pos)
        tmp = np.fromstring(cmat, np.float32).reshape(4, 4)[:3, :3]
        assert cmat is not None
        del phi, theta, pos, right, up, distance, tmp

        # Compute random orientation of cube. Every cube will have the same
        # orientation.
        u = np.linalg.svd(np.random.uniform(-1, 1, size=(3, 3)))[0]
        tm = ds2sim.camera.compileCameraMatrix(right=u[0], up=u[1], pos=[0, 0, 0])
        assert tm is not None
        del u

        # Render each cube into a file.
        for j in range(10):
            dst_path = os.path.join(param.dst_path, f'{j:02d}')
            os.makedirs(dst_path, exist_ok=True)

            # Apply the transform to the current cube.
            h.setNodeTransMat(nodes[j], tm)

            # Render the scene to an image.
            img = h.renderScene(cmat, param.width, param.height, skybox=False)
            img = PIL.Image.fromarray(np.flipud(img))
            fname = os.path.join(dst_path, f'{i:04d}.jpg')
            img.save(fname, 'jpeg', quality=param.jpg_quality)

            # Set the scale to zero to make the cube invisible, because we only
            # want to see one cube in each image, not all 10.
            h.setNodeTransPes(nodes[j], [0, 0, 0], [0, 0, 0], [0, 0, 0])
            del j, img
        del tm
    print(f'Saved pure cube images to <{dst_path}>')


def renderGroundTruthBackground(param):
    """Render a scene devoid of cubes from random angles/positions.

    The scene still comprises the skybox and a randomly placed platform.

    Args:
        param (namespace): command line parameters returned by argparse
    """
    h = ds2sim.horde.Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Ensure the target directory exists.
    dst_path = os.path.join(param.dst_path, 'background')
    os.makedirs(dst_path, exist_ok=True)

    # Add a light far away to mimic the sun.
    addSun(h)

    # Add the platform.
    platform = h.addNode(default_resources['base'])

    # Render the empty scenes from several random angles/positions.
    for i in range(param.num_images):
        pos = 50 * np.random.uniform(-1, 1, 3)
        euler = 180 * np.random.uniform(-1, 1, 3)
        scale = 1 * np.random.uniform(0, 1, 3)
        h.setNodeTransPes(platform, pos.tolist(), euler.tolist(), scale.tolist())
        del pos, euler, scale

        # Compute random right/up/position vector for camera.
        u, _, _ = np.linalg.svd(np.random.uniform(-1, 1, size=(3, 3)))
        pos = 100 * np.random.uniform(-1, 1, 3)
        cmat = ds2sim.camera.compileCameraMatrix(right=u[0], up=u[1], pos=pos)
        assert cmat is not None
        del u

        # Render the scene and save the image.
        img = h.renderScene(cmat, param.width, param.height, skybox=True)
        img = PIL.Image.fromarray(np.flipud(img))
        fname = os.path.join(dst_path, f'{i:04d}.jpg')
        img.save(fname, 'jpeg', quality=param.jpg_quality)
    print(f'Saved background images to <{dst_path}>')


def renderFlightPath(param):
    """Populate the scene with cubes and render a virtual flight through it.

    This will also produce a meta.pickle file in the destination folder
    (specified on the command line). This file contains meta information about
    the scene, most notable the location and label of each cube as seen on the
    respective frame.

    Args:
        param (namespace): command line parameters returned by argparse
    """
    # Ensure the target directory exists.
    dst_path = os.path.join(param.dst_path, 'flightpath')
    os.makedirs(dst_path, exist_ok=True)

    h = ds2sim.horde.Engine(param.width, param.height, param.fov)
    default_resources = h.loadDefaultResources()

    # Add the platform.
    node = h.addNode(default_resources['base'])
    h.setNodeTransPes(node, [0, -35, 0], [0, 0, 0], [1, .2, 1])
    del node

    # Define a map that associates integers with human readable class names.
    # For technical reasons, the Zero label must be "background".
    int2name = {i + 1: str(i) for i in range(10)}
    int2name[0] = 'background'

    # Initialise the random generator to ensure reproducible results.
    np.random.seed(param.seed)

    # Draw a sequence of integers [0-9]. These will be the numbers displayed on
    # the cube. Use this sequence to also compile the corresponding list of
    # machine readable labels for each cube, ie add 1 to each number because
    # Zero is the background label.
    cube_nums = np.random.choice(np.arange(10), param.num_cubes)
    cube_labels = cube_nums + 1

    # Create random positions and orientations for each cube.
    cube_pos = 50 * np.random.uniform(-1, 1, size=(param.num_cubes, 3))
    cube_rot = 180 * np.random.uniform(-1, 1, size=(param.num_cubes, 3))

    # Each cube has the same size in the scene.
    scale = 2 * np.ones(3)

    # Create a flight path, that is, create the camera- position and vectors.
    # To ensure a "smooth" path that also connects the end to the beginning, we
    # will use trigonometric functions only.
    cam_mat = []
    for phi in np.linspace(0, 2 * np.pi, param.num_frames):
        pos = (30 * np.cos(phi), 20 * np.sin(phi), 30 * np.sin(phi))
        right = np.array([np.cos(3 * phi), 0, np.sin(3 * phi)])
        cmat = ds2sim.camera.compileCameraMatrix(right=right, up=[0, 1, 0], pos=pos)
        cam_mat.append(cmat)
        del phi, pos, right, cmat

    # Add each cube to the scene and set its transform.
    nodes = []
    for idx, (pos, rot, num) in enumerate(zip(cube_pos, cube_rot, cube_nums)):
        node = h.addNode(default_resources[num])
        h.setNodeTransPes(node, pos, rot, scale)
        nodes.append(node)
        del node

    # Move the camera through the scene and save each frame as a JPG file.
    for frame, cmat in enumerate(cam_mat):
        # Save the screen coordinate of all visible cubes.
        _ = projectCubePositions(param, cmat, cube_labels, cube_pos)
        pos3d, bb_labels, bb_rects, pick_idx = _

        # Render the scene with the light on.
        light_node = addSun(h)
        img_light = h.renderScene(cmat, param.width, param.height, False)
        img_light = np.flipud(img_light)
        h.h3dRemoveNode(light_node)

        # Render the scene with all lights off. The objects will still be
        # (somewhat) visible due to the ambient light, but there will be no
        # shadows of any kind.
        img_all = h.renderScene(cmat, param.width, param.height, False)
        img_all = np.flipud(img_all)
        img_all = PIL.Image.fromarray(img_all)

        obj_regions = np.zeros(img_light.shape[:2], np.uint16)
        pixel_labels = np.zeros_like(obj_regions)
        for obj_idx in pick_idx:
            node = nodes[obj_idx]
            pos = cube_pos[obj_idx]
            rot = cube_rot[obj_idx]

            # Render the scene without the current cube.
            h.setNodeTransPes(node, pos, rot, [0] * 3)
            diff = h.renderScene(cmat, param.width, param.height, False)
            diff = np.array(np.flipud(diff), np.float32)
            h.setNodeTransPes(node, pos, rot, scale)

            # Compare the images with- and without the cube to determine which
            # pixels belong to it.
            diff = np.max(np.abs(img_all - diff), axis=2)
            diff_idx = np.nonzero(diff)

            # Skip this cube if it has barely an influence on the image. This
            # happens if the cube is away, covered mostly by another object, or
            # it is barely inside the camera frustrum.
            if len(diff_idx[0]) < 128:
                continue

            # Record which cube occupies which pixels. Then record the label
            # for each pixel as well.
            obj_regions[diff_idx] = obj_idx
            pixel_labels[diff_idx] = cube_labels[obj_idx]

        # Plot the image and label mask (debug only).
        if param.debug:
            plt.figure()
            plt.subplot(1, 3, 1).imshow(img_light)
            plt.subplot(1, 3, 2).imshow(obj_regions, clim=[0, len(pick_idx)])
            plt.subplot(1, 3, 3).imshow(pixel_labels, clim=[0, len(int2name)])

        # Save the meta information.
        fname_img = os.path.join(dst_path, f'{frame:04d}.jpg')
        fname_meta = os.path.join(dst_path, f'{frame:04d}-meta.json.bz2')
        img_light = PIL.Image.fromarray(img_light)
        img_light.save(fname_img, 'jpeg', quality=param.jpg_quality)
        meta = {
            'seed': param.seed,
            'frame_no': frame,
            'int2name': int2name,
            'num_frame': param.num_frames,
            'num_cubes': param.num_cubes,
            'pos3d': np.round(pos3d, 2).tolist(),
            'bb_labels': bb_labels.tolist(),
            'bb_rects': bb_rects.tolist(),
            'pixel-labels': pixel_labels.tolist(),
        }
        bz2.open(fname_meta, 'wb').write(json.dumps(meta, indent=2).encode('utf8'))

    print(f'Saved flight path images to <{dst_path}>')

    if param.debug:
        plt.show()


def main():
    # Ensure the image sequence is repeatable.
    np.random.seed(0)

    param = parseCmdline()
    if param.mode == 'flight':
        renderFlightPath(param)
    elif param.mode == 'cubes':
        renderGroundTruthCubes(param)
    elif param.mode == 'background':
        renderGroundTruthBackground(param)
    elif param:
        assert False, f'Unknown mode <{param.mode}>'


if __name__ == '__main__':
    main()
